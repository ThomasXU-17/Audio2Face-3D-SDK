<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio2Face REST API - éŸ³é¢‘è½¬é¢éƒ¨åŠ¨ç”»</title>
    <style>
        :root {
            --primary-color: #76b900;
            --primary-dark: #5a8f00;
            --bg-dark: #1a1a1a;
            --bg-card: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --success-color: #4caf50;
            --error-color: #f44336;
            --warning-color: #ff9800;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            color: var(--text-primary);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .logo svg {
            width: 48px;
            height: 48px;
            fill: var(--primary-color);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary-color), #a8e063);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 24px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-badge {
            background: var(--primary-color);
            color: #000;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(118, 185, 0, 0.05);
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: rgba(118, 185, 0, 0.1);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(118, 185, 0, 0.15);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 0.9rem;
            color: var(--text-secondary);
            opacity: 0.7;
        }

        #audioFile {
            display: none;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: rgba(118, 185, 0, 0.1);
            border-radius: 8px;
            border: 1px solid var(--primary-color);
        }

        .file-icon {
            font-size: 2rem;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .file-size {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: #000;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(118, 185, 0, 0.3);
        }

        .btn-secondary {
            background: var(--border-color);
            color: var(--text-primary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #505050;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        /* Status */
        .status-box {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .status-box.loading {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid var(--warning-color);
        }

        .status-box.success {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid var(--success-color);
        }

        .status-box.error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid var(--error-color);
        }

        .status-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-message {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Progress */
        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: var(--text-secondary);
        }

        /* Settings */
        .settings-grid {
            display: grid;
            gap: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-label {
            font-weight: 500;
            color: var(--text-primary);
        }

        .setting-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        input[type="text"],
        input[type="number"],
        select {
            padding: 10px 15px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1rem;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Results */
        .result-item {
            padding: 15px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .result-info {
            flex: 1;
        }

        .result-label {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .result-value {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-family: monospace;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* API Status */
        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-dark);
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error-color);
        }

        .status-dot.connected {
            background: var(--success-color);
        }

        .logs {
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            margin-top: 15px;
        }

        .log-entry {
            padding: 4px 0;
            color: var(--text-secondary);
        }

        .log-entry.error {
            color: var(--error-color);
        }

        .log-entry.success {
            color: var(--success-color);
        }

        .log-entry.info {
            color: #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
                <h1>Audio2Face RestAPI</h1>
            </div>
            <p class="subtitle">ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶,ç”Ÿæˆé¢éƒ¨åŠ¨ç”»æ•°æ®</p>
            <div class="api-status" id="apiStatus">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">æ£€æŸ¥APIè¿æ¥...</span>
            </div>
        </header>

        <!-- Step 1: Upload Audio -->
        <div class="card">
            <div class="card-title">
                <span class="step-badge">1</span>
                ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶
            </div>
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸµ</div>
                <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½éŸ³é¢‘æ–‡ä»¶åˆ°æ­¤å¤„</div>
                <div class="upload-hint">æ”¯æŒ WAV, MP3, OGG, FLAC, M4A æ ¼å¼</div>
            </div>
            <input type="file" id="audioFile" accept=".wav,.mp3,.ogg,.flac,.m4a">
            <div id="fileInfo" class="hidden"></div>
        </div>

        <!-- Step 2: Settings -->
        <div class="card">
            <div class="card-title">
                <span class="step-badge">2</span>
                æ¨ç†è®¾ç½®
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <label class="setting-label">é€‰æ‹©éŸ³é¢‘æ–‡ä»¶</label>
                    <div style="display: flex; gap: 10px;">
                        <select id="existingAudioSelect" style="flex: 1;">
                            <option value="">-- ä½¿ç”¨ä¸Šä¼ çš„æ–°æ–‡ä»¶ --</option>
                        </select>
                        <button class="btn btn-secondary" onclick="refreshAudioList()" style="padding: 8px 16px;">ğŸ”„ åˆ·æ–°</button>
                    </div>
                    <span class="setting-description">é€‰æ‹©å·²ä¸Šä¼ çš„éŸ³é¢‘æ–‡ä»¶é‡æ–°æ¨ç†ï¼Œæˆ–ä¸Šä¼ æ–°æ–‡ä»¶</span>
                </div>
                <div class="setting-item">
                    <label class="setting-label">å¯¼å‡ºæ ¼å¼</label>
                    <select id="exportFormat">
                        <option value="json">JSON (Blendshape Weights)</option>
                        <option value="usd">USD (Geometry Cache)</option>
                        <option value="emotions">JSON (Emotion Keys)</option>
                    </select>
                    <span class="setting-description">é€‰æ‹©å¯¼å‡ºçš„åŠ¨ç”»æ•°æ®æ ¼å¼</span>
                </div>
                <div class="setting-item">
                    <label class="setting-label">å¸§ç‡ (FPS)</label>
                    <input type="number" id="fps" value="25" min="1" max="120" step="1">
                    <span class="setting-description">å¯¼å‡ºåŠ¨ç”»çš„å¸§ç‡ï¼Œé»˜è®¤25 FPS</span>
                </div>
            </div>
        </div>

        <!-- Step 3: Process -->
        <div class="card">
            <div class="card-title">
                <span class="step-badge">3</span>
                ç”Ÿæˆå¹¶ä¸‹è½½
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" id="processBtn" disabled>
                    <span id="processBtnIcon">â–¶ï¸</span>
                    <span id="processBtnText">å¼€å§‹å¤„ç†</span>
                </button>
                <button class="btn btn-secondary" id="downloadBtn" disabled>
                    â¬‡ï¸ ä¸‹è½½ç»“æœ
                </button>
            </div>

            <div id="statusContainer" class="hidden"></div>
            <div id="logsContainer" class="hidden">
                <div class="logs" id="logs"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration - ä½¿ç”¨å½“å‰è®¿é—®çš„åœ°å€ï¼Œæ”¯æŒå±€åŸŸç½‘è®¿é—®
        const SERVER_BASE = window.location.origin;  // åŠ¨æ€è·å–æœåŠ¡å™¨åœ°å€
        const API_BASE = `${SERVER_BASE}/api/a2f`;  // Audio2Face REST API (é€šè¿‡ä»£ç†)
        
        // æœåŠ¡å™¨ç«¯è·¯å¾„å°†ç”±åç«¯ API æä¾›
        let USD_FILE = null;
        let EXPORT_DIR = null;
        let a2fInstanceName = null;  // ä» GetInstances API è·å–
        
        // State
        let uploadedAudioFile = null;
        let uploadedAudioPath = null;
        let resultFilePath = null;
        let resultFileName = null;
        let isProcessing = false;

        // Elements
        const uploadArea = document.getElementById('uploadArea');
        const audioFileInput = document.getElementById('audioFile');
        const fileInfo = document.getElementById('fileInfo');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusContainer = document.getElementById('statusContainer');
        const logsContainer = document.getElementById('logsContainer');
        const logs = document.getElementById('logs');
        const apiStatus = document.getElementById('apiStatus');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');

        // Initialize
        async function init() {
            // ä»åç«¯è·å–é…ç½®
            try {
                const configResponse = await fetch(`${SERVER_BASE}/api/config`);
                if (configResponse.ok) {
                    const config = await configResponse.json();
                    USD_FILE = config.usd_file;
                    EXPORT_DIR = config.export_dir;
                    console.log('æœåŠ¡å™¨é…ç½®å·²åŠ è½½:', config);
                } else {
                    throw new Error('æ— æ³•è·å–æœåŠ¡å™¨é…ç½®');
                }
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
                showStatus('error', 'åˆå§‹åŒ–å¤±è´¥', 'æ— æ³•ä»æœåŠ¡å™¨è·å–é…ç½®ä¿¡æ¯');
                return;
            }
            
            // æ£€æŸ¥APIçŠ¶æ€
            checkAPIStatus();
            setInterval(checkAPIStatus, 10000); // Check every 10s
        }
        
        init(); // å¯åŠ¨åˆå§‹åŒ–

        // Refresh audio list from RootPath
        async function refreshAudioList() {
            if (!EXPORT_DIR) {
                addLog('error', 'è¯·å…ˆç­‰å¾…é…ç½®åŠ è½½å®Œæˆ');
                return;
            }

            try {
                addLog('info', 'æ­£åœ¨è·å–éŸ³é¢‘åˆ—è¡¨...');
                
                // Get player instances first
                const instancesResponse = await fetch(`${API_BASE}/A2F/Player/GetInstances`);
                if (!instancesResponse.ok) {
                    throw new Error('è·å–æ’­æ”¾å™¨å®ä¾‹å¤±è´¥');
                }
                const instances = await instancesResponse.json();
                
                if (!instances.result || !instances.result.regular || instances.result.regular.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°æ’­æ”¾å™¨å®ä¾‹');
                }
                
                const playerInstance = instances.result.regular[0];
                
                // Set root path first
                await fetch(`${API_BASE}/A2F/Player/SetRootPath`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        a2f_player: playerInstance,
                        dir_path: EXPORT_DIR
                    })
                });
                
                // Get available tracks
                const tracksResponse = await fetch(`${API_BASE}/A2F/Player/GetTracks`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ a2f_player: playerInstance })
                });
                
                if (!tracksResponse.ok) {
                    throw new Error('è·å–éŸ³é¢‘åˆ—è¡¨å¤±è´¥');
                }
                
                const tracks = await tracksResponse.json();
                console.log('å¯ç”¨éŸ³é¢‘åˆ—è¡¨:', tracks);
                
                const select = document.getElementById('existingAudioSelect');
                select.innerHTML = '<option value="">-- ä½¿ç”¨ä¸Šä¼ çš„æ–°æ–‡ä»¶ --</option>';
                
                if (tracks.result && tracks.result.length > 0) {
                    tracks.result.forEach(track => {
                        const option = document.createElement('option');
                        option.value = track;
                        option.textContent = track;
                        select.appendChild(option);
                    });
                    addLog('success', `æ‰¾åˆ° ${tracks.result.length} ä¸ªéŸ³é¢‘æ–‡ä»¶`);
                } else {
                    addLog('info', 'å½“å‰ç›®å½•ä¸‹æ²¡æœ‰éŸ³é¢‘æ–‡ä»¶');
                }
            } catch (error) {
                addLog('error', `åˆ·æ–°éŸ³é¢‘åˆ—è¡¨å¤±è´¥: ${error.message}`);
                console.error(error);
            }
        }

        // Check API status
        async function checkAPIStatus() {
            try {
                console.log('æ£€æŸ¥APIçŠ¶æ€:', API_BASE);
                const response = await fetch(`${API_BASE}/status`);
                console.log('APIå“åº”:', response.status, response.ok);
                if (response.ok) {
                    const data = await response.text();
                    console.log('APIæ•°æ®:', data);
                    statusDot.classList.add('connected');
                    statusText.textContent = 'APIå·²è¿æ¥';
                } else {
                    statusDot.classList.remove('connected');
                    statusText.textContent = `APIè¿æ¥å¤±è´¥ (${response.status})`;
                }
            } catch (error) {
                console.error('APIé”™è¯¯:', error);
                statusDot.classList.remove('connected');
                statusText.textContent = 'APIæœªè¿è¡Œ: ' + error.message;
            }
        }

        // Upload area click
        uploadArea.addEventListener('click', () => {
            audioFileInput.click();
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        // File input change
        audioFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        // Handle file selection
        function handleFileSelect(file) {
            uploadedAudioFile = file;
            uploadedAudioPath = null; // Will be set after upload
            resultFilePath = null;
            
            // Clear existing audio selection
            document.getElementById('existingAudioSelect').value = '';
            
            // Show file info
            fileInfo.innerHTML = `
                <div class="file-info">
                    <div class="file-icon">ğŸµ</div>
                    <div class="file-details">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${formatFileSize(file.size)}</div>
                    </div>
                    <button class="btn btn-secondary" onclick="clearFile()">âœ• ç§»é™¤</button>
                </div>
            `;
            fileInfo.classList.remove('hidden');
            uploadArea.classList.add('hidden');
            processBtn.disabled = false;
            downloadBtn.disabled = true;
            
            addLog('info', `å·²é€‰æ‹©æ–‡ä»¶: ${file.name}`);
        }
        
        // Handle existing audio selection
        document.getElementById('existingAudioSelect').addEventListener('change', (e) => {
            if (e.target.value) {
                // Clear uploaded file
                uploadedAudioFile = null;
                uploadedAudioPath = null;
                resultFilePath = null;
                fileInfo.classList.add('hidden');
                uploadArea.classList.remove('hidden');
                audioFileInput.value = '';
                processBtn.disabled = false;
                downloadBtn.disabled = true;
                addLog('info', `å·²é€‰æ‹©éŸ³é¢‘: ${e.target.value}`);
            }
        });

        // Clear file
        function clearFile() {
            uploadedAudioFile = null;
            uploadedAudioPath = null;
            resultFilePath = null;
            fileInfo.classList.add('hidden');
            uploadArea.classList.remove('hidden');
            processBtn.disabled = true;
            downloadBtn.disabled = true;
            audioFileInput.value = '';
            statusContainer.classList.add('hidden');
            logsContainer.classList.add('hidden');
            logs.innerHTML = '';
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Add log entry
        function addLog(type, message) {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            logsContainer.classList.remove('hidden');
        }

        // Show status
        function showStatus(type, title, message) {
            statusContainer.className = `status-box ${type}`;
            statusContainer.innerHTML = `
                <div class="status-title">
                    ${type === 'loading' ? '<span class="spinner"></span>' : ''}
                    ${title}
                </div>
                <div class="status-message">${message}</div>
            `;
            statusContainer.classList.remove('hidden');
        }

        // Process button click
        processBtn.addEventListener('click', async () => {
            const existingAudio = document.getElementById('existingAudioSelect').value;
            if ((!uploadedAudioFile && !existingAudio) || isProcessing) {
                if (!existingAudio && !uploadedAudioFile) {
                    alert('è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶æˆ–é€‰æ‹©å·²æœ‰éŸ³é¢‘');
                }
                return;
            }

            isProcessing = true;
            processBtn.disabled = true;
            downloadBtn.disabled = true;
            
            try {
                addLog('info', 'å¼€å§‹å¤„ç†æµç¨‹...');
                showStatus('loading', 'å¤„ç†ä¸­...', 'æ­£åœ¨åˆå§‹åŒ–Audio2Faceæ¨ç†');

                // Step 1: Load USD file
                addLog('info', 'Step 1: åŠ è½½USDæ–‡ä»¶...');
                await loadUSD();

                // Step 2: Upload audio and set track
                addLog('info', 'Step 2: ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶...');
                await uploadAndSetAudio();

                // Step 3: Generate animation
                addLog('info', 'Step 3: ç”Ÿæˆé¢éƒ¨åŠ¨ç”»...');
                await generateAnimation();

                // Step 4: Export results
                addLog('info', 'Step 4: å¯¼å‡ºç»“æœ...');
                await exportResults();

                // Success
                showStatus('success', 'âœ… å¤„ç†å®Œæˆ!', 'åŠ¨ç”»æ•°æ®å·²ç”Ÿæˆ,ç‚¹å‡»ä¸‹è½½æŒ‰é’®è·å–ç»“æœæ–‡ä»¶');
                addLog('success', 'å¤„ç†å®Œæˆ!å¯ä»¥ä¸‹è½½ç»“æœäº†');
                downloadBtn.disabled = false;

            } catch (error) {
                showStatus('error', 'âŒ å¤„ç†å¤±è´¥', error.message);
                addLog('error', `é”™è¯¯: ${error.message}`);
            } finally {
                isProcessing = false;
                processBtn.disabled = false;
            }
        });

        // Step 1: Load USD
        async function loadUSD() {
            const response = await fetch(`${API_BASE}/A2F/USD/Load`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_name: USD_FILE })
            });

            if (!response.ok) {
                throw new Error('åŠ è½½USDæ–‡ä»¶å¤±è´¥');
            }

            addLog('success', 'USDæ–‡ä»¶åŠ è½½æˆåŠŸ');
        }

        // Step 2: Upload and set audio
        async function uploadAndSetAudio() {
            // Check if using existing audio
            const existingAudio = document.getElementById('existingAudioSelect').value;
            let audioFileName;
            
            if (existingAudio) {
                // Using existing audio file
                addLog('info', `ä½¿ç”¨å·²æœ‰éŸ³é¢‘: ${existingAudio}`);
                audioFileName = existingAudio;
            } else {
                // Upload new file to server
                if (!uploadedAudioFile) {
                    throw new Error('è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶æˆ–é€‰æ‹©å·²æœ‰éŸ³é¢‘');
                }
                
                addLog('info', 'æ­£åœ¨ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶åˆ°æœåŠ¡å™¨...');
                const formData = new FormData();
                formData.append('file', uploadedAudioFile);
                
                const uploadResponse = await fetch(`${SERVER_BASE}/api/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    throw new Error('ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶å¤±è´¥');
                }

                const uploadResult = await uploadResponse.json();
                uploadedAudioPath = uploadResult.path;
                audioFileName = uploadResult.filename;
                addLog('success', `æ–‡ä»¶å·²ä¸Šä¼ : ${audioFileName}`);
            }
            
            // Get player instances
            addLog('info', 'è·å–æ’­æ”¾å™¨å®ä¾‹...');
            const instancesResponse = await fetch(`${API_BASE}/A2F/Player/GetInstances`);
            if (!instancesResponse.ok) {
                throw new Error('è·å–æ’­æ”¾å™¨å®ä¾‹å¤±è´¥');
            }
            const instances = await instancesResponse.json();
            
            // è¯¦ç»†è°ƒè¯•æ—¥å¿—
            console.log('GetInstances å“åº”:', instances);
            console.log('instances.result:', instances.result);
            
            // GetInstances è¿”å›çš„ result æ˜¯å¯¹è±¡ {regular: [], streaming: []}
            if (!instances.result || !instances.result.regular || instances.result.regular.length === 0) {
                throw new Error('æœªæ‰¾åˆ°æ’­æ”¾å™¨å®ä¾‹');
            }
            
            // ä½¿ç”¨ç¬¬ä¸€ä¸ª regular æ’­æ”¾å™¨å®ä¾‹
            const playerInstance = instances.result.regular[0];
            console.log('playerInstance:', playerInstance);
            
            addLog('info', `æ‰¾åˆ° ${instances.result.regular.length} ä¸ªæ’­æ”¾å™¨å®ä¾‹`);
            addLog('success', `ä½¿ç”¨æ’­æ”¾å™¨å®ä¾‹: ${playerInstance}`);
            
            // ä¿å­˜A2Få®ä¾‹åç”¨äºåç»­æ“ä½œ
            a2fInstanceName = playerInstance;

            // Set audio root path (ä½¿ç”¨ä¸Šä¼ æ–‡ä»¶æ‰€åœ¨ç›®å½•)
            const audioDir = EXPORT_DIR;
            const rootPathRequest = {
                a2f_player: playerInstance,
                dir_path: audioDir
            };
            console.log('rootPathRequest å¯¹è±¡:', rootPathRequest);
            console.log('rootPathRequest JSON:', JSON.stringify(rootPathRequest));
            addLog('info', `SetRootPath è¯·æ±‚: ${JSON.stringify(rootPathRequest)}`);
            
            const setRootResponse = await fetch(`${API_BASE}/A2F/Player/SetRootPath`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(rootPathRequest)
            });

            if (!setRootResponse.ok) {
                const errorText = await setRootResponse.text();
                throw new Error(`è®¾ç½®éŸ³é¢‘æ ¹è·¯å¾„å¤±è´¥: ${errorText}`);
            }

            addLog('success', `éŸ³é¢‘æ ¹è·¯å¾„è®¾ç½®æˆåŠŸ: ${audioDir}`);
            
            // Set the track with time range
            const setTrackResponse = await fetch(`${API_BASE}/A2F/Player/SetTrack`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    a2f_player: playerInstance,
                    file_name: audioFileName,
                    time_range: [0, -1]  // -1 means end of audio
                })
            });

            if (!setTrackResponse.ok) {
                const errorText = await setTrackResponse.text();
                throw new Error(`è®¾ç½®éŸ³é¢‘è½¨é“å¤±è´¥: ${errorText}`);
            }

            addLog('success', 'éŸ³é¢‘è½¨é“è®¾ç½®æˆåŠŸ');
        }

        // Step 3: Generate animation
        async function generateAnimation() {
            if (!a2fInstanceName) {
                throw new Error('æœªæ‰¾åˆ°A2Få®ä¾‹åç§°');
            }

            // Generate emotion keys (this triggers the inference)
            const response = await fetch(`${API_BASE}/A2F/A2E/GenerateKeys`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    a2f_instance: a2fInstanceName
                })
            });

            if (!response.ok) {
                throw new Error('ç”ŸæˆåŠ¨ç”»å¤±è´¥');
            }

            addLog('success', 'é¢éƒ¨åŠ¨ç”»ç”ŸæˆæˆåŠŸ');
        }

        // Step 4: Export results
        async function exportResults() {
            const exportFormat = document.getElementById('exportFormat').value;
            const fps = parseInt(document.getElementById('fps').value) || 25;
            
            if (!a2fInstanceName) {
                throw new Error('æœªæ‰¾åˆ°A2Få®ä¾‹åç§°');
            }
            
            // ä½¿ç”¨éŸ³é¢‘æ–‡ä»¶åä½œä¸ºå¯¼å‡ºæ–‡ä»¶å‰ç¼€
            const existingAudio = document.getElementById('existingAudioSelect').value;
            let audioBaseName;
            if (existingAudio) {
                audioBaseName = existingAudio.replace(/\.[^/.]+$/, '');  // å»æ‰æ‰©å±•å
            } else if (uploadedAudioFile) {
                audioBaseName = uploadedAudioFile.name.replace(/\.[^/.]+$/, '');  // å»æ‰æ‰©å±•å
            } else {
                throw new Error('æ— æ³•ç¡®å®šéŸ³é¢‘æ–‡ä»¶å');
            }
            
            let endpoint, requestBody, filename, expectedFileName;

            if (exportFormat === 'json') {
                // Export blendshapes
                endpoint = `${API_BASE}/A2F/Exporter/ExportBlendshapes`;
                filename = audioBaseName;  // ä¸åŠ .jsonåç¼€ï¼ŒAPIä¼šè‡ªåŠ¨æ·»åŠ 
                
                // Get blendshape solvers
                addLog('info', 'è·å– BlendShape è§£ç®—å™¨...');
                const solversResponse = await fetch(`${API_BASE}/A2F/Exporter/GetBlendShapeSolvers`);
                if (!solversResponse.ok) {
                    throw new Error('è·å–BlendShapeè§£ç®—å™¨å¤±è´¥');
                }
                
                const solvers = await solversResponse.json();
                addLog('info', `æ‰¾åˆ° ${solvers.result ? solvers.result.length : 0} ä¸ªè§£ç®—å™¨`);
                
                if (!solvers.result || solvers.result.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°BlendShapeè§£ç®—å™¨');
                }

                requestBody = {
                    solver_node: solvers.result[0],
                    export_directory: EXPORT_DIR,
                    file_name: filename,
                    format: 'json',
                    batch: false,
                    fps: fps
                };
                // API ä¼šè‡ªåŠ¨æ·»åŠ  _bsweight.json åç¼€
                expectedFileName = `${filename}_bsweight.json`;

            } else if (exportFormat === 'emotions') {
                // Export emotion keys
                endpoint = `${API_BASE}/A2F/Exporter/ExportEmotionKeys`;
                filename = audioBaseName;
                requestBody = {
                    a2f_instance: a2fInstanceName,
                    export_directory: EXPORT_DIR,
                    file_name: filename
                };
                expectedFileName = `${filename}.json`;  // å¯èƒ½éœ€è¦æ ¹æ®å®é™…APIè¡Œä¸ºè°ƒæ•´

            } else {
                // Export geometry cache (USD)
                endpoint = `${API_BASE}/A2F/Exporter/ExportGeometryCache`;
                filename = audioBaseName;
                requestBody = {
                    export_directory: EXPORT_DIR,
                    file_name: filename,
                    start_frame: 0,
                    end_frame: -1  // -1 means all frames
                };
                expectedFileName = `${filename}.usd`;
            }

            addLog('info', `å¯¼å‡ºå‚æ•°: ${JSON.stringify(requestBody, null, 2)}`);
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`å¯¼å‡ºç»“æœå¤±è´¥: ${errorText}`);
            }

            resultFilePath = `${EXPORT_DIR}/${expectedFileName}`;
            resultFileName = expectedFileName;
            addLog('success', `ç»“æœå·²å¯¼å‡ºåˆ°: ${resultFilePath}`);
            addLog('info', `ä¸‹è½½æ–‡ä»¶å: ${expectedFileName}`);
        }

        // Download button click
        downloadBtn.addEventListener('click', async () => {
            if (!resultFileName) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„ç»“æœæ–‡ä»¶');
                return;
            }

            addLog('info', 'å¼€å§‹ä¸‹è½½ç»“æœæ–‡ä»¶...');
            
            try {
                // Download file from server
                const downloadUrl = `${SERVER_BASE}/api/download/${resultFileName}`;
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = resultFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                addLog('success', `ä¸‹è½½å·²å¼€å§‹: ${resultFileName}`);
            } catch (error) {
                addLog('error', `ä¸‹è½½å¤±è´¥: ${error.message}`);
                alert(`ä¸‹è½½å¤±è´¥,æ–‡ä»¶è·¯å¾„: ${resultFilePath}\næ‚¨å¯ä»¥æ‰‹åŠ¨ä»æœåŠ¡å™¨å¤åˆ¶æ–‡ä»¶ã€‚`);
            }
        });
    </script>
</body>
</html>
